+ # C# 基础
  + ## 装箱和拆箱
    装箱是把值类型转换为引用类型，拆箱是把引用类型转换为值类型，值类型如果没有进行装箱操作依然存储在栈上。装箱与拆箱的过程很损耗性能。
  + ## C# new 关键字的作用
    实例化对象、类型约束、重写非抽象方法的方法
  
  + ## string是值类型还是引用？字符串的不可变性？为什么设计成不可变的？
    + 字符串是引用类型，赋值的操作是值类型的。
    + 字符串的不可变性是指引用不可变，所有的方法返回的字符串都是新的对象，
    + 设计成不可变的是因为字符串常量池的需要，允许string的HashCode，效率优化，安全性等。
    + 字符串在内存中是以char的方式存储。
  
  + ## stringBuilder的作用？
    StringBuilder默认大小是16个长度，存在动态扩容机制，每次扩容是当前的两倍，StringBuilder的作用是保证饮用地址不变，每次都在当前的地址进行扩容。
  
  + ## 字符串是引用类型为什么会支持==对比？
    ==比较的是引用类型的地址，会支持是因为重载运算符。

  + ## stringEquals和==的区别Equals**的实现原理**
    + ==：比较的是两个变量的引用地址
    + Equals：Equals比较的永远是变量的内容是否相同，Equals存在拆装箱的问题，重写IEquatable避免，重写Equals需要重写GetHasCode
  
  + ## int类型为什么可以生命为Null？
    int类型是一个结构体，能被赋值为null的不一定是引用类型，在.Net 2.0的FCL中添加了一个可为空的Nullble结构体，编译器帮我们做了一层转换，所以值类型可以为空了。

  + ## class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？
    随类型对象存储在内存的加载堆上，因为加载堆不受GC管理，其生命周期随AppDomain，不会被GC回收。
  + ### 委托、Func、和Action 三者的区别是啥??
    + 委托是引用类型
    + Func<T>委托代表着拥有返回值的泛型委托;
    + Action<T>委托代表返回值为空 void 的委托，它也有一些列重载，最多拥有16个输入参数。
    + delegate关键字的委托声明，同时委托要指明方法参数和返回值，写法与方法类似。
    + event事件的本质是一种委托。
  
  + ## 泛型 / 泛型缓存
    + 代码的复用，解决了装拆箱的性能问题。
    + 必须是一个泛型类在第一次执行的时候会执行静态构造函数，之后就不会再执行到；它会根据传入的不同类型，为每一个类型生成一个副本；在使用泛型缓存的时候，其实相当于是去调用一个普通的类；跟普通缓存的区别：泛型缓存效率远远高于普通缓存
  + ## ArrayList、List
    + ArrayList对象的大小是按照其中存储的数据来动态扩充与收缩，不限定对象类型，不能实例化
    + List<T>可通过索引访问的对象的强类型列表  
  
  + ## 对象的复制
    + 浅复制：浅复制通过调用objectMemberwiseClone实现，复制者和被复制者引用相同
    + 深复制：深复制是创建一个新的对象和引用，并不继承原始对象，需要自己实现。
  
  + ## 堆和栈的区别？
    + 栈由系统自动分配，而堆是人为申请开辟；
    + 栈获得的空间较小，而堆获得的空间较大；
    + 栈由系统自动分配，速度较快，而堆一般速度比较慢；
    + 栈是连续的空间，而堆是不连续的空间；
  
  + ## 结构和类的区别
    + 结构体是值类型，类是引用类型，主要区别。其他的区别：
    + 结构不支持无惨构造函数，不支持析构函数，并且不能有protected修饰；
    + 结构常用于数据存储，类class多用于行为；
    + class需要用new关键字实例化对象，struct可以不适用new关键字；
    + class可以为抽象类，struct不支持抽象；
  
  + ## struct(结构体)和class的区别？它们在内存中是如何分配的？
    + struct是结构体属于值类型，存储在栈上面，class是引用类型，引用类型的地址存储在栈上面，
      一个引用类型的对象即使它没有字段他的初始化需要24个字节这是64位操作系统中，分别是头字节（同步块索引）、方法表指针和对象各个字段。所以struct和class都有两个相同的int类型属性，他们所占用的空间大小是不同的。引用对象占用的空间要比struct多一些。
    + struct存储在栈上，栈的性能仅次于CPU的寄存器，值类型是用完就释放了，但是引用类型在用完之后回收指针，但是具体的内存占用还在堆上，由GC去回收堆内存。
  
  + ## 多线程、异步编程基础
    + ### 如何避免死锁,死锁产生的原因？
      + #### 产生：
        互斥条件、不剥夺条件、请求和保持条件、循环等待条件。
      + #### 避免
        加锁顺序、加锁时限、死锁检测、破坏互斥条件、允许资源共享、预先静态分配、环路等待。
    + 
    
    + ### 线程安全集合
      System.Collections.Concurrent命名空间下都是线程安全集合。
      + ConcurrentDictionary
      + ConcurrentQueue
      + ConcurrentQueue
      + ConcurrentBag
      + ConcurrentStack
      + BlockingCollection
    
    + ### 除了官方提供的这些安全集合还有那些线程同步方式？
      除了使用官方提供的这些线程安全集合，我们还可以通过下面这些方式保证线程或者共享数据的线程安全。
      + #### Monitor
        Monitor可以避免死锁，内部有一个计数器用来判断有没有获取到锁。
      + #### Mutex
        Mutex是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock和Monitor是一个混合锁，一般建议使用Lock或者Monitor更好，因为性能更好。
      + #### lock
        处理并发使用；用来锁定代码，保证代码块的完整运行而不会被其他线程中断；底层实现也是基于Monitor
      + #### AutoResetEvent
        是基于信号量的实现。类似于一个旋转门，每次只能一个。
      + #### Interlocked
        Interlocked是一个原子操作，它是基于CAS的一个实现。CAS其实就是读值->比较->转换的三步操作，也称之为乐观锁。
      + #### Semaphore、SemaphoreSlim
        Semaphore是SemaphoreSlim的旧版本使用内核时间方式实现，SemaphoreSlim不是使用内核信号量来实现的，不支持进程同步，Semaphore支持进程同步。
      + #### 什么是信号量？如何实现一个信号量？
        + 信号量的使用时用来保护共享资源的，使资源在同一时间只有一个线程或进程访问，信号量是操作系统提供给开发人员的一种机制，用来协调共享资源，解决资源竞争的。
        + 每个信号量都有一个整数 value 和一个进程链表 list。当一个进程必须等待信号量时，就被添加到进程链表。操作 signal() 从等待、进程链表上取走一个进程，并加以唤醒。
      + #### 异步代码块中如何使用锁？一段代码一次只允许5个线程执行如何实现？
        在异步代码块中可以使用Semaphore或者SemaphoreSlim。这两种都可以做到同一时间允许多少个线程访问。

  + ## 表达式树的构建过程？
  + ## 反射（Reflection）是什么？简述反射的作用？
    + 反射是可以在应用程序运行时获取(类、结构、委托、接口、枚举)等成员的(方法、属性、事件、构造函数、成员名称、限定符、参数等)，也可以使用反射动态的创建类型实例。它的作用是：获取元数据属性、程序集中的类型。
    + 
  + 