# 入门知识 
  ## 1、为什么需要K8s
  ### 1.1 单体应用和微服务
  + 在传统系统中，我们都是以单体应用的形式来开发的，单体应用由很多个组件组成，这些组件和模块紧密的耦合在一起，由于他们是在同一个操作系统中运行，所以开发、部署、管理他们必须是同一个进程进行，对单体应用来说，即时某个组件中一个小的修改，都需要重新部署应用，组件间缺乏模块的边界定义，相互依赖，系统复杂度提升，整体应用质量也急剧恶化。
  + 运行一个单体应用，通常需要一台能为整个应用提供足够资源的高性能服务器，为了应对不断增长的系统符合，我们需要通过增加CPU、内存或其他资源的方式对服务器进行垂直扩展。
  + 上述的问题迫使我们将一个复杂大型的单体应用拆分成可独立部署的微服务模块，下图是将一个庞大复杂的单体应用拆解成微服务，每个服务以独立的进程运行，服务之间通信可以通过HTTP同步协议、AMQP异步协议或者RPC远程成调用的方式进行通信，每个服务可以用最适合的开发语言来实现。![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220719085314.png)
  ### 1.2系统扩容
  + 在单体系统中的扩容是针对的整个系统，而棉线微服务的架构，我们的扩容只需要针对到具体的单个系统模块，这就意味着你可以选择仅扩容那些需要更多资源的服务，而保持其他服务在原来的规模上继续运行。
  ## 2、Docker和K8s
  + 本章将会介绍 Docker 和 Kubernetes 的一些基础知识，掌握 Docker 的组成结构以及 Docker 是怎么隔离容器、隔离硬件资源的，了解为什么用 Kubernetes，Kubernetes 的组成、结构等，我们会学习到很多 K8S 的术语。
  ### 2.1 Docker基础知识
  + 要使用K8s我们需要先学习Docker，因为在K8s早期是基于Docker容器运行的，很多文章也将Docker归为虚拟化，但是个人认为Docker并不是虚拟化的一个应用，Docker的底层他是通过Linux的两个机制实现的，第一个是Linux的命名空间，它的作用是使每个进程只看到他自己的系统视图（文件、网络接口、进程、主机名等），第二个是Linux控制组(cgroups)它的作用是用来限制进程能使用的资源量（CPU、内存、网络带宽等）。
    #### 2.2 容器化和虚拟机区别
    + 容器化与虚拟机比较，容器更加轻量级，它允许在相同的硬件上运行更多数量的组件，容器化是运行在同一个操作系统，而一个容器仅仅是运行在宿主机上被隔离的单个进程，容器化共享一组系统进程。而虚拟机的本质是需要运行一组系统进程，这就产生了除了组件进程消耗以外的额外计算资源损耗。容器化相比虚拟机更加轻量级。因为虚拟机额外的开销，可能会导致没有足够的资源给每个应用开一个虚拟机，最终我们会选择将多个应用程序分组放到每个虚拟机内，但是，当我们使用容器时，能够让每个应用有一个容器，最终的效果就是我们一个裸机可以运行更多的应用程序。Todo【缺图】
    #### 2.3 容器实现隔离机制介绍
    #### **Linux命名空间隔离进程**
      + 容器使用Linux命名空间隔离进程，每个Linux系统最初仅有一个命名空间，所有的系统资源都属于这一个命名空间。但是你可以额外的创建自己的命名空间，以及在他们之间组织协调各种资源，对于一个进程，可以在其中一个命名空间中运行它。该进程将只能看到同一个命名空间下的资源。会存在多种类型的多个命名空间，所以一个进程不单单仅属于某一个命名空间，而是属于每个类型的一个命名空间。
        + Mount
        + Process ID
        + NetWork
        + Inter-process communicaion (ipd)
        + UTS
        + User ID（User）
      + 每种命名空间被用来隔离一组特定的资源，例如：UTS 命名空间决定了运行在命名空间里的进程能看见哪些主机名和域名。通过分派两个不同的 UTS 命名空间给一对进程， 能使它们看见不同的本地主机名。通俗来说，这两个进程就好像正在两个不同的机器上运行一样（至少就主机名而言是这样的）。
    #### **进程可用资源限制**
      + 容器化的另一个隔离性是指限制容器使用的系统资源，例如限制（CPU、内存、网络带宽等），它是通过cgroups来实现的，cgroups是一个Linux内核功能，它被用来限制一个进程或一组进程的资源使用。使用量不能超过被分配的量。这种方式下，进程不能过分使用为其他进程保留的资源，这和进程运行在不同的机器上是类型的。
    ### 2.4 Docker镜像的组成
    + 在 Docker 镜像中，操作系统是高度精简的，可能只有一个精简的 Shell，甚至没有 Shell。而且镜像中的操作系统还不包含内核，容器都是共享所在的宿主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象），容器中查看到的 Linux 内核版本与宿主机一致。Docker 镜像的是由一系统文件组成的。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725090724.png)
    ### 2.5联合文件系统
    + Linux 有名为 Unionfs 的文件系统服务，可以将不同文件夹中的文件联合到一个文件夹中。Unionfs 有称为分支的概念，一个分支包含了多个目录和文件，多个分支可以挂载在一起，在挂载时，可以指定一个分支优先级大于另一个分支，这样当两个分支都包含相同的文件名时，一个分支会优先于另一个分支，在合并的目录中，会看到高优先级分支的文件。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725090806.png)
    + Docker 中，层层组成镜像的技术也是联合文件系统，Union File System。Docker 镜像中的操作系统是根文件系统，在上一小节的图片中，可以看到有 bin、boot 等目录。我们都知道，Docker 镜像是由多层文件组成的，在上面的示例图片中有三层组成：根文件系统、环境依赖包、应用程序文件。当镜像层生成后，便不能被修改，如果再进行操作，则会在原来的基础上生成新的镜像层，层层联合，最终生成镜像。当然生成的镜像可能会因为层数太多或者操作过多，导致出现大量冗余，镜像臃肿。
    + Docker 的镜像分层是受 Linux Unionfs 启发而开发的，Docker 支持多种文件联合系统，如 AUFS、OverlayFS、VFS 等。
  ## 3、Docker组成结构
  + 本节将了解 Docker 的组成部件和结构。
    ### 3.1、Docker服务与客户端
    + Docker 由 Service 和 Client 两部分组成，在服务器上可以不安装 Docker Client，可以通过 Http Api 等方式与 Docker Servie 通讯。在安装了 Docker 的主机上执行命令 docker version 查看版本号。
    ### 3.2、Docker 客户端
    + 要想跟 Docker Server 通讯，可以使用 Restful API、UNIX 套接字或网络接口(Socket)。Docker 官方的客户端是一个二进制命令行程序，使用 Go 语言编写，我们也可以使用 C#、Java 等语言写一个类似的程序，Docker 客户端不需要安装到 Docker Server 所在的主机，Client 跟 Server 可以远程通讯。
    + Docker 的客户端是许多 Docker 用户与 Docker 交互的主要方式，当我们使用 docker run 之类的命令时，客户端会将这些命令发送到 Docker Server，由 Docker Server 解析并执行命令。
    + Docker for Linux 中最为常见的同主机通讯方式是 Unix 域套接字。很多软件都支持使用域套接字与 Docker 通讯，例如 CI/CD 软件 Jenkins，使用域套接字连接 Docker，能够利用 Docker 启动容器构建应用程序以及使用 Docker 来做一些不可描述的事情。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725092014.png)
    ### 3.3、Docker网络
    + Docker 有 bridge、none、host、container 四种网络模式，提供网络隔离、端口映射、容器间互通网络等各种支持，下面开门见山地直接介绍这四种网络模式。
      | 网络模式      | 参数         | 说明 |
      | ------------- | ------------ | --------------------------- |
      | host模式      | -–net=host   | 容器和宿主机共享 Network namespace。                         |
      | container模式 | –-net={id}   | 容器和另外一个容器共享 Network namespace。 kubernetes 中的pod就是多个容器共享一个 Network namespace。 |
      | none模式      | –-net=none   | 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，配置IP等。 |
      | bridge模式    | -–net=bridge | 默认为该模式，通过 -p 指定端口映射。  |

    + **3.3.1 bridge 模式**
      
      bridge 模式称为网桥模式，首先 Docker 会在主机上创建一个名为 docker0 的虚拟网桥，这个虚拟网络处于七层网络模型的数据链路层，每当创建一个新的容器时，容器都会通过 docker0 与主机的网络连接，docker0 相当于网桥。
    + **3.3.2 none 模式**
      
      这种网络模式下容器只有 lo 回环网络，没有其他网卡，这种类型的网络没有办法联网，外界也无法访问它，封闭的网络能很好地保证容器的安全性。
    + **3.3.3 host 模式**
      
      host 模式会让容器与主机共享网络，此时映射的端口可能会生产冲突，但是容器的其余部分(文件系统、进程等)依然是隔离的，此时容器与宿主机共享网络。
    + **container 模式**
    
      container 模式可以让多个容器之间相互通讯，即容器之间共享网络。
  ## 4、Docker和Kubernetes Pod的关系
  + 现在 Docker 的流行程度越来越高，越来越多的公司使用 Docker 打包和部署项目。但是也有很多公司只是追求新技术，将以前的单体应用直接打包为镜像，代码、配置方式等各方面保持不变，使用 Docker 后，并没有带来多大的便利，反而使得配置、启动过程变得更加繁杂，更难调试。本章将讨论Docker与 Pod 的关系，了解如何更好地将应用容器化。
    + ### 4.1、什么是容器化应用
    + containerized applications 指容器化的应用，我们常常说使用镜像打包应用程序，使用 Docker 发布、部署应用程序，那么当你的应用成功在 Docker 上运行时，称这个应用是 containerized applications。容器化的应用程序与它们所需的库、二进制文件和配置文件绑定到一个容器中。通常，容器都包含一个应用程序，以及正确执行二进制程序所需的依赖库、文件等，例如 Linux 文件系统+应用程序组成一个简单的容器。通过将容器限制为单个进程，问题诊断和更新应用程序都变得更加容易。与 VM(虚拟机)不同，容器不包含底层操作系统，因此容器被认为是轻量级的。Kubernentes 容器属于开发领域。容器在操作系统之上，提供了 CPU、内存、网络、存储等资源的虚拟化，为应用在不同服务器里提供了一致的运行时环境。开发者可以通过容器创建一个可预测的环境，能够保证在开发、调试、生产时的环境都是一致的，减少开发团队和运维团队可以减少调试和诊断问题时，因环境差异带来的麻烦。同时，应用运行在一个沙盒中，对应用和系统进行了隔离，提高了安全性，还能限制应用程序使用的计算资源。
    + 什么是Pod
    + 最简单的说法就是将多个容器打包起来一起运行，这个整体就是 Pod。在上一部分的 Docker 网络中，介绍了 container 网络模式，Pod 正是通过这种网络模式，让 Pod 中的容器共享网络，也就是说，Pod 中的容器，网络是互通的，容器之间不能使用相同的端口。Pod 是 Kubernetes 集群中最小的执行单位。在 Kubernetes 中，容器不直接在集群节点上运行，而是将一个或多个容器封装在一个 Pod 中，接着将 Pod 调度到节点上运行，这些容器会一起被运行、停止，它们是一个整体。Pod 中的所有容器共享相同的资源和本地网络，从而简化了 Pod 中应用程序之间的通讯。在 Pod 中，所有容器中的进程共享网络，可以通过 127.0.0.1、localhost 相互进行访问。
    + ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220829154410.png)容器之间是彼此完全隔离的，但是在k8s中设计者期望的是隔离一组容器，而不是单个容器，所以pod作用是将一组容器进行打包，我个人理解的pod是一个容器组，在相同的容器组内的容器可以共享一些资源，可以理解为它并没有完全隔离，k8s通过配置docker让一个pod内的所有容器运行在相同命名空间下，而不是每个容器都有自己的命名空间，一个pod包含多个容器，但是相同pod容器只能运行在一个Node节点内，不可跨节点运行。