# K8s 
  ## 1、为什么需要K8s
  ### 1.1 单体应用和微服务
  + 在传统系统中，我们都是以单体应用的形式来开发的，单体应用由很多个组件组成，这些组件和模块紧密的耦合在一起，由于他们是在同一个操作系统中运行，所以开发、部署、管理他们必须是同一个进程进行，对单体应用来说，即时某个组件中一个小的修改，都需要重新部署应用，组件间缺乏模块的边界定义，相互依赖，系统复杂度提升，整体应用质量也急剧恶化。
  + 运行一个单体应用，通常需要一台能为整个应用提供足够资源的高性能服务器，为了应对不断增长的系统符合，我们需要通过增加CPU、内存或其他资源的方式对服务器进行垂直扩展。
  + 上述的问题迫使我们将一个复杂大型的单体应用拆分成可独立部署的微服务模块，下图是将一个庞大复杂的单体应用拆解成微服务，每个服务以独立的进程运行，服务之间通信可以通过HTTP同步协议、AMQP异步协议或者RPC远程成调用的方式进行通信，每个服务可以用最适合的开发语言来实现。![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220719085314.png)
  ### 1.2系统扩容
  + 在单体系统中的扩容是针对的整个系统，而棉线微服务的架构，我们的扩容只需要针对到具体的单个系统模块，这就意味着你可以选择仅扩容那些需要更多资源的服务，而保持其他服务在原来的规模上继续运行。
  ## 2、Docker和K8s
  + 本章将会介绍 Docker 和 Kubernetes 的一些基础知识，掌握 Docker 的组成结构以及 Docker 是怎么隔离容器、隔离硬件资源的，了解为什么用 Kubernetes，Kubernetes 的组成、结构等，我们会学习到很多 K8S 的术语。
  ### 2.1 Docker基础知识
  + 要使用K8s我们需要先学习Docker，因为在K8s早期是基于Docker容器运行的，很多文章也将Docker归为虚拟化，但是个人认为Docker并不是虚拟化的一个应用，Docker的底层他是通过Linux的两个机制实现的，第一个是Linux的命名空间，它的作用是使每个进程只看到他自己的系统视图（文件、网络接口、进程、主机名等），第二个是Linux控制组(cgroups)它的作用是用来限制进程能使用的资源量（CPU、内存、网络带宽等）。
    #### 2.2 容器化和虚拟机区别
    + 容器化与虚拟机比较，容器更加轻量级，它允许在相同的硬件上运行更多数量的组件，容器化是运行在同一个操作系统，而一个容器仅仅是运行在宿主机上被隔离的单个进程，容器化共享一组系统进程。而虚拟机的本质是需要运行一组系统进程，这就产生了除了组件进程消耗以外的额外计算资源损耗。容器化相比虚拟机更加轻量级。因为虚拟机额外的开销，可能会导致没有足够的资源给每个应用开一个虚拟机，最终我们会选择将多个应用程序分组放到每个虚拟机内，但是，当我们使用容器时，能够让每个应用有一个容器，最终的效果就是我们一个裸机可以运行更多的应用程序。Todo【缺图】
    #### 2.3 容器实现隔离机制介绍
    #### **Linux命名空间隔离进程**
      + 容器使用Linux命名空间隔离进程，每个Linux系统最初仅有一个命名空间，所有的系统资源都属于这一个命名空间。但是你可以额外的创建自己的命名空间，以及在他们之间组织协调各种资源，对于一个进程，可以在其中一个命名空间中运行它。该进程将只能看到同一个命名空间下的资源。会存在多种类型的多个命名空间，所以一个进程不单单仅属于某一个命名空间，而是属于每个类型的一个命名空间。
        + Mount
        + Process ID
        + NetWork
        + Inter-process communicaion (ipd)
        + UTS
        + User ID（User）
      + 每种命名空间被用来隔离一组特定的资源，例如：UTS 命名空间决定了运行在命名空间里的进程能看见哪些主机名和域名。通过分派两个不同的 UTS 命名空间给一对进程， 能使它们看见不同的本地主机名。通俗来说，这两个进程就好像正在两个不同的机器上运行一样（至少就主机名而言是这样的）。
    #### **进程可用资源限制**
      + 容器化的另一个隔离性是指限制容器使用的系统资源，例如限制（CPU、内存、网络带宽等），它是通过cgroups来实现的，cgroups是一个Linux内核功能，它被用来限制一个进程或一组进程的资源使用。使用量不能超过被分配的量。这种方式下，进程不能过分使用为其他进程保留的资源，这和进程运行在不同的机器上是类型的。
    ### 2.4 Docker镜像的组成
    + 在 Docker 镜像中，操作系统是高度精简的，可能只有一个精简的 Shell，甚至没有 Shell。而且镜像中的操作系统还不包含内核，容器都是共享所在的宿主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象），容器中查看到的 Linux 内核版本与宿主机一致。Docker 镜像的是由一系统文件组成的。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725090724.png)
    ### 2.5联合文件系统
    + Linux 有名为 Unionfs 的文件系统服务，可以将不同文件夹中的文件联合到一个文件夹中。Unionfs 有称为分支的概念，一个分支包含了多个目录和文件，多个分支可以挂载在一起，在挂载时，可以指定一个分支优先级大于另一个分支，这样当两个分支都包含相同的文件名时，一个分支会优先于另一个分支，在合并的目录中，会看到高优先级分支的文件。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725090806.png)
    + Docker 中，层层组成镜像的技术也是联合文件系统，Union File System。Docker 镜像中的操作系统是根文件系统，在上一小节的图片中，可以看到有 bin、boot 等目录。我们都知道，Docker 镜像是由多层文件组成的，在上面的示例图片中有三层组成：根文件系统、环境依赖包、应用程序文件。当镜像层生成后，便不能被修改，如果再进行操作，则会在原来的基础上生成新的镜像层，层层联合，最终生成镜像。当然生成的镜像可能会因为层数太多或者操作过多，导致出现大量冗余，镜像臃肿。
    + Docker 的镜像分层是受 Linux Unionfs 启发而开发的，Docker 支持多种文件联合系统，如 AUFS、OverlayFS、VFS 等。
  ## 3、Docker组成结构
  + 本节将了解 Docker 的组成部件和结构。
    ### 3.1、Docker服务与客户端
    + Docker 由 Service 和 Client 两部分组成，在服务器上可以不安装 Docker Client，可以通过 Http Api 等方式与 Docker Servie 通讯。在安装了 Docker 的主机上执行命令 docker version 查看版本号。
    ### 3.2、Docker 客户端
    + 要想跟 Docker Server 通讯，可以使用 Restful API、UNIX 套接字或网络接口(Socket)。Docker 官方的客户端是一个二进制命令行程序，使用 Go 语言编写，我们也可以使用 C#、Java 等语言写一个类似的程序，Docker 客户端不需要安装到 Docker Server 所在的主机，Client 跟 Server 可以远程通讯。
    + Docker 的客户端是许多 Docker 用户与 Docker 交互的主要方式，当我们使用 docker run 之类的命令时，客户端会将这些命令发送到 Docker Server，由 Docker Server 解析并执行命令。
    + Docker for Linux 中最为常见的同主机通讯方式是 Unix 域套接字。很多软件都支持使用域套接字与 Docker 通讯，例如 CI/CD 软件 Jenkins，使用域套接字连接 Docker，能够利用 Docker 启动容器构建应用程序以及使用 Docker 来做一些不可描述的事情。
    ![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220725092014.png)
    ### 3.3、容器运行时
    